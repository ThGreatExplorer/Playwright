package ast

object ExprRenamer:

    // Private iterator that will produce fresh names
    // The counter is monotonically increasing + surface syntax does not allow 
    // numbers in names => all the names generated by this method will be globally
    // unique.
    private val nameAnnotGenerator = Iterator.from(0)
    private def uniquifyName(x: String) : String = x + nameAnnotGenerator.next().toString()

    def unqiuifyVarNames(vars : Set[String]) : Map[String, String] = 
        vars.map(originalName => (originalName, uniquifyName(originalName))).toMap

    def getAllVars(e : CleanExpr) : Set[String] = e match
        case Expr.Num(n) => Set()
            
        case Expr.Var(x) => Set(x)
            
        case Expr.BinOpExpr(lhs, op, rhs) => Set(lhs, rhs) 
            
        case Expr.NewInstance(cname, args) => args.toSet

        case Expr.GetField(instance, field) => Set(instance)
            
        case Expr.CallMethod(instance, method, args) => args.toSet.incl(instance)
            
        case Expr.IsInstanceOf(instance, cname) => Set(instance)

    def renameVars(e : CleanExpr, renameMap : Map[String, String]) : CleanExpr = e match
        case Expr.Num(n) => Expr.Num(n)
            
        case Expr.Var(x) => Expr.Var(renameMap(x))
            
        case Expr.BinOpExpr(lhs, op, rhs) => Expr.BinOpExpr(renameMap(lhs), op, renameMap(rhs))
            
        case Expr.NewInstance(cname, args) => Expr.NewInstance(cname, args.map(renameMap(_)))

        case Expr.GetField(instance, field) => Expr.GetField(renameMap(instance), field)
            
        case Expr.CallMethod(instance, method, args) => 
            Expr.CallMethod(renameMap(instance), method, args.map(renameMap(_)))
            
        case Expr.IsInstanceOf(instance, cname) => 
            Expr.IsInstanceOf(renameMap(instance), cname)
