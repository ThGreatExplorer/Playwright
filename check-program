#! /bin/sh
#| -*- racket -*-
exec racket -tm "$0" -- ${1+"$@"}
|#
#lang racket

;; clones a given git repo, ckecks that A/ exists, runs make as needed, and then runs ./xjson
;; if any step fails, the program explains what went wrong as much as possible

(provide main)

;; ---------------------------------------------------------------------------------------------------
(require racket/sandbox)

;; ---------------------------------------------------------------------------------------------------
(define BASIC-INPUT "query")

(define NAME "check-program") 
(define HOME (find-system-path 'home-dir))
(define TEMP (build-path HOME "check-program-tmp/"))
(define MAKE "Makefile")
(define XJSN "xtypes")
(define AAAA "9")
(define GIT  "git@github.khoury.northeastern.edu:cs4400-f25/")

(define (main . args)
  (let/cc stop
    (set! *stop stop)
    (define repo-name (parse-args args))
    (define git-url (args->git-url repo-name))
    (dynamic-wind ;; make sure to clean up resources 
     (λ ()
       (create-temporary-directory TEMP))
     (λ ()
       (parameterize ((current-directory TEMP))
         (git-clone git-url)
         (parameterize ((current-directory repo-name))
           (define the-path (A-exists? "in" TEMP))
           (parameterize ([current-directory the-path])
             (run-make-if-it-exists)
             (run-xjson-if-exists-and-is-executable)))))
     (λ ()
       (delete-temporary-directory TEMP)
       (if exit-status (exit 0) (exit 1))))))

;; escape on exn situations 
(define exit-status #true)
(define *stop (λ (x) (error '*stop "can't happen ~a\n" x)))
(define (stop! y)
  (eprintf (~a NAME ": " y))
  (set! exit-status #false)
  (*stop (void)))

;; ---------------------------------------------------------------------------------------------------
;; check arguments and extract the path to the git repo
;; KNOWN .GIT 
(define (args->git-url repo-name)
  (string-append GIT repo-name ".git"))

(define (parse-args args)
  (match args
    [(list arg)
     arg]
    [_ (stop! "expected one argument naming your pair's git repo\n")]))
  

;; ---------------------------------------------------------------------------------------------------
;; creates the temporary directory
;; KNOWN ~/check-program-tmp/
(define (create-temporary-directory TEMP)
  (with-handlers ([exn:fail:filesystem? (no-temporary-directory TEMP "create")])
    (make-directory TEMP)))

(define (delete-temporary-directory TEMP)
  (with-handlers ([exn:fail:filesystem? (no-temporary-directory TEMP "delete")])
    (delete-directory/files TEMP #:must-exist? #false)))

;; signals exn if create|delete-temporary-directory doesn't succeed 
(define [(no-temporary-directory TEMP action) xn]
  (define msg (exn-message xn))
  (stop! (format "cannot ~a temp directory: ~a\n~a\n" action TEMP msg)))

;; ---------------------------------------------------------------------------------------------------
;; clone git repo into current directory
;; KNOWN git repo is local 
(define (git-clone git-url)
  (unless (system (~a "git clone " git-url))
    (stop! (format "cannot clone git repo, double check path: ~a\n" git-url))))

;; ---------------------------------------------------------------------------------------------------
#; {-> PathString}
;; does A exist
(define (A-exists? . _)
  (define the-path AAAA)
  (unless (directory-exists? the-path)
    (stop! (format "repo-level directory ~a does not exist\n" AAAA)))
  the-path)

;; ---------------------------------------------------------------------------------------------------
;; run make if a Makefile exists and create xjson presumably 
(define (run-make-if-it-exists)
  (when (file-exists? MAKE)
    (unless (system "make")
      (stop! "something went wrong with running make"))))

;; ---------------------------------------------------------------------------------------------------
(define (run-xjson-if-exists-and-is-executable)
  (cond
    [(not (file-exists? XJSN))
     (stop! (format "~a does not exist in ~a\n" XJSN [current-directory]))]
    [(not (member 'execute (file-or-directory-permissions XJSN)))
     (stop! (format "~a is not executable\n" XJSN))]
    [(not (run-it))
     (stop! (format "something went wrong with running ~a and feeding an EXAMPLE \n" XJSN))]
    [else
     (printf "~a successfully launched, consumed a EXAMPLE, and returned something.\n" XJSN)
     (printf "This test script did _not_ check the output.\n")]))

(define (run-it)
  (printf "cloned, specified directories exist, ~a is exectuable, launching\n" XJSN)
  (with-handlers ([exn:fail:resource?
                   (λ (xn) (printf "~a failed: ~a\n" XJSN (exn:fail:resource-resource xn)) #false)]
                  [string?
                   (λ (s)
                     (printf "**************************\n")
                     (printf "the executable errored out\n")
                     (printf s)
                     (printf "**************************\n")
                     #false)]
                  [exn:fail?
                   (λ (xn) (printf "BAD\n") (pretty-print (exn-message xn)) #false)])
    (parameterize ([current-custodian (make-custodian)])
      (define-values (from0 to0 pid from-err query)
        (apply values (apply process*/ports #f #f #f (~a "./" XJSN) '())))
      (printf "pushing EXAMPLE into ~a\n" XJSN)
      (with-limits 2 10 (writeln 'aName to0) (newline) (flush-output to0))
      (printf "waiting for result from ~a\n" XJSN)
      (with-limits 4 10 (get-result to0 from0 from-err))
      (custodian-shutdown-all (current-custodian)))))

(define (get-result to0 from0 from-err0)
  (close-output-port to0)
  (define x (port->string from-err0))
  (define j (read from0))
  (cond
    [(>= (string-length x) 1)
     (raise x)]
    [else 
     (displayln j)
     j]))
